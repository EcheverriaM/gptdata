      SUBROUTINE NOTES.AUP.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * AUP NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.AUP.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            *
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            *
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
            RETURN
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-AUP', '', ERROR)
      RETURN

      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE ":NOTEKEY; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-AUP', 'ST.NOTES', NOTE.REC, ERROR)

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      NOTEKEY<2> = 11; * NUMBER OF ATTRIBUTES TO CHECK - THIS IS ABOVE THE 11 ALREADY CHECKING
      NOTEKEY<3> = 12
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)
      
      * NEED TO UPDATE ST.SECURITY WITH THE AUP INFORMATION...
      *.  NOPE THAT IS DONE BY A BACKGROUND JOB IN SIS.WWW,BP, MAKE.INCIDENT
      *

      RETURN

      SUBROUTINE NOTES.CALLNURSE.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * CALL NURSE NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN
      OPEN "DICT ST.NOTES" TO F.DICT.NOTES ELSE ERROR = "CANNOT OPEN DICT NOTES"; RETURN
      OPEN "JSONCONTROL"  TO F.JCONTROL ELSE ERROR = "CANNOT OPEN JSONCONTROL"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.CALLNURSE.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      *
      *DOME = "SELECT ST.NOTES ":NOTEKEY
      *EXECUTE DOME CAPTURING OUTPUT
      *CALL JSON.OBJECT.SUB(JSON, 'NOTES-MEDGIVEN-MYFORM', '', ERROR)

      * attributes 70-72 will contain multivalue rows of the CALL NURSE
      *
      READ NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "CANNOT READ THIS NOTE ":NOTEKEY
      READV MYVARS FROM F.JCONTROL, "NOTES-CALLNURSE-MYFORM", 3
      *
      MYLOC = ''
      IF DEBUG THEN WRITE MYVARS ON F.RF, "MYVARS"
      FOR I = 1 TO DCOUNT(MYVARS, VM)
         THIS.VAR = MYVARS<1,I>
         READV  TMP FROM F.DICT.NOTES, THIS.VAR, 2
         MYLOC<1,I> = TMP
      NEXT I
      JSONDEF = "myformList"
      JSONDEF<2> = MYVARS
      JSONDEF<3> = MYLOC
      JSONDEF<4> = "Y"
      * FIX THE DATE TIME
      FOR X = 1 TO DCOUNT(NOTE.REC<70>, VM)

         VUEDATE = ''
         THIS.DATE = NOTE.REC<70,X>
         THIS.TIME = NOTE.REC<71,X>

         CALL CONVERT.DATE.SUB( VUEDATE, THIS.DATE, THIS.TIME, ERROR)
         IF DEBUG THEN WRITE VUEDATE ON F.RF, 'VDATE'
         NOTE.REC<70,X> = VUEDATE

      NEXT X

      CALL JSON.BUILDMY.SUB(JSON, JSONDEF, NOTE.REC, ERROR)
      IF ERROR = 0 THEN ERROR = ''
      IF ERROR NE '' THEN WRITE ERROR ON F.RF, 'ERROR'

      IF JSON = '{"myformList":[}' THEN
         JSON = ''
      END
      IF DEBUG THEN WRITE JSON ON F.RF, 'AFTERMYFORMLIST'

      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-CALLNURSE', '', ERROR)

      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-CALLNURSE', 'ST.NOTES', NOTE.REC, ERROR)
      *
      READV MYVARS FROM F.JCONTROL, "NOTES-CALLNURSE-MYFORM", 3
      *MYVARS = "mgDateTimemgShotmgSugarmgLevelmgCarbsmgCorrectionmgTotalUnitsmgCarbsCorrectionmgLcarbsmgUnitsmgLunitsmgTotalmgDosageused"
      FOR I = 1 TO DCOUNT(MYVARS, VM)
         THIS.VAR = MYVARS<1,I>
         READV  ATTR FROM F.DICT.NOTES, THIS.VAR, 2
         
         CALL WPARSEJSON(BODY, THIS.VAR, THIS.VAL, ERROR)

         IF THIS.VAR = "cnDateTime" THEN
            THIS.DATE = ''; THIS.TIME = ''

            CALL CONVERT.DATE.SUB( THIS.VAL, THIS.DATE, THIS.TIME, ERROR)

            NOTE.REC = INSERT(NOTE.REC, 70, 1; THIS.DATE)
            NOTE.REC = INSERT(NOTE.REC, 71, 1; THIS.TIME)
         END ELSE
            IF THIS.VAL = '' THEN THIS.VAL = " "
            NOTE.REC = INSERT(NOTE.REC, ATTR, 1; THIS.VAL)
         END
      NEXT I
      WRITE NOTE.REC ON F.NOTES, NOTEKEY

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      NOTEKEY<2> = 70; * NUMBER OF ATTRIBUTES TO CHECK
      NOTEKEY<3> = 72; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      CALL NWBUILDJSON.SUB(JSON, 'message', "Record Saved", '', ERROR)

      RETURN

      SUBROUTINE NOTES.COUNSELOR.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * COUNSELOR NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.COUNSELOR.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-COUNSELOR', '', ERROR)
      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-COUNSELOR', 'ST.NOTES', NOTE.REC, ERROR)

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      *NOTEKEY<2> = 12; * NUMBER OF ATTRIBUTES TO CHECK
      *NOTEKEY<3> = 12; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      *
      RETURN



      SUBROUTINE NOTES.COUNSELOR.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * FOOD ALLERGIES NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.FOODALS.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-FOODALS', '', ERROR)

      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      CALL JSON.OBJECT.SUB(JSON, 'NOTES-FOODALS-MYFORM', '', ERROR)

      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-FOODALS', 'ST.NOTES', NOTE.REC, ERROR)      
      CALL SAVE.JSONCONTROL('NOTES-FOODALS-MYFORM', 'ST.NOTES', NOTE.REC, ERROR)

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      NOTEKEY<2> = 30; * NUMBER OF ATTRIBUTES TO CHECK
      NOTEKEY<3> = 39; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      *
      RETURN

      SUBROUTINE NOTES.HEALTHPLAN.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * HEALTHPLAN NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.FOODALS.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-HEALTHPLAN', '', ERROR)

      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      CALL JSON.OBJECT.SUB(JSON, 'NOTES-HEALTHPLAN-MYFORM', '', ERROR)

      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-HEALTHPLAN', 'ST.NOTES', NOTE.REC, ERROR)      
      CALL SAVE.JSONCONTROL('NOTES-HEALTHPLAN-MYFORM', 'ST.NOTES', NOTE.REC, ERROR)

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      NOTEKEY<2> = 30; * NUMBER OF ATTRIBUTES TO CHECK
      NOTEKEY<3> = 39; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      *
      RETURN


      SUBROUTINE NOTES.IEP504.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * MEDICAL GIVEN NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.IEP504.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-IEP504', '', ERROR)
      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-IEP504', 'ST.NOTES', NOTE.REC, ERROR)

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      NOTEKEY<2> = 60; * NUMBER OF ATTRIBUTES TO CHECK
      NOTEKEY<3> = 63; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      *
      RETURN


      SUBROUTINE NOTES.PRIVATE.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * PRIVATE NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.INCIDENT.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)


      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-PRIVATE', '', ERROR)

      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      CALL JSON.OBJECT.SUB(JSON, 'NOTES-INCIDENTS', '', ERROR)

      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-PRIVATE', 'ST.NOTES', NOTE.REC, ERROR)
      CALL SAVE.JSONCONTROL('NOTES-INCIDENTS', 'ST.NOTES', NOTE.REC, ERROR)

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      *NOTEKEY<2> = 12; * NUMBER OF ATTRIBUTES TO CHECK
      *NOTEKEY<3> = 12; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      *
      RETURN

      SUBROUTINE NOTES.MASTER(JSON, ERROR)
      *
      *
      * 3/22  NOTES MASTER PROGRAM.  CALLED BY SSD.MASTER.
      *
      $INCLUDE I_STDFILES_JOOMLA      
      
      DEBUG = 0
      * WE NEED TO SEE IF THIS IS PRODUCTION OR BACKUP SERVER SO WE CAN DELETE WWW DIRECTORYS OF FILES.
      UFILE = "/usr/lib/pick"
      OPEN "",UFILE TO UNIX.FILEV THEN
         READ SERVER.REC FROM UNIX.FILEV,"master.slave" THEN
            SERVER.TYPE = SERVER.REC<1>
            IF SERVER.TYPE = "SLAVE" THEN DEV = 1 ELSE DEV = 0
         END
      END
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN 'NOTES.TYPE' TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN
      OPEN 'ST.SECURITY' TO F.ST.SECURITY ELSE ERROR = "CANNOT OPEN ST.SECURITY"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.MASTER.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "cmd", CMD, ERROR)
      CMD = OCONV(CMD, 'MCU')
      CMD = FIELD(CMD, '-', 1)
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *

      * SHOULD CALL SECURITY CHECK

      CALL GET.SECURITYREC.SUB(SECURITY.REC, SECURITY.KEY, EMPNUM, ERROR)
      IF ERROR = 0 THEN ERROR = ''
      IF ERROR NE '' THEN ERROR = "NOTES.MASTER, SECURITY ":ERROR; GOTO STOP.ROUTINE
      *
      IF SECURITY.KEY = "1832" THEN DEBUG = 0
      *
      * WE WILL NEED THE SCHOOL FROM THE SECURITY RECORD TO OPEN FILES.
      *  NEED TO FIGURE OUT HOW TO HANDLE SUBSTITUTE CHECKOUT SCREEN.
      MY.SCHOOL = SECURITY.REC<6>
      MY.PRINTER = SECURITY.REC<13>

      * WHAT ABOUT THE SECURITY RECORD
      *IF SECURITY.REC<8> = "PRINCIPAL" THEN
      *PRINCIPAL = 1
      *END ELSE
      *PRINCIPAL = 0
      *END
      *IF SECURITY.REC<8> = 'DISTRICT' THEN
      *PRINCIPAL = 1
      *END

      POSITION = SECURITY.REC<8>

      READ NOTES.SECURITY FROM F.NEXTNUM, "NOTES.SECURITY" ELSE NOTES.SECURITY = ''
      LOCATE SECURITY.KEY IN NOTES.SECURITY<1> SETTING POS THEN POSITION = "PRINCIPAL"
      LOCATE SECURITY.KEY IN NOTES.SECURITY<2> SETTING POS THEN POSITION = "SECRETARY"
      LOCATE SECURITY.KEY IN NOTES.SECURITY<3> SETTING POS THEN POSITION = "COOK"

      IF POSITION = '' THEN POSITION = "TEACHER"

      SECURITY.REC.SCHOOL = SECURITY.REC<6>

      BEGIN CASE
            *
         CASE CMD = "GETSALT"
            *
            CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)
            READ SEC.REC FROM F.ST.SECURITY, STKEY ELSE SEC.REC = ''
            IF SEC.REC<30> = '' THEN
               CALL PASSWORD.RANDOM.SUB(PASSWORD)
               SEC.REC<30> = PASSWORD
               WRITE SEC.REC ON F.ST.SECURITY, STKEY
            END
            CALL NWBUILDJSON.SUB(JSON, "salt", SEC.REC<30>, '', ERROR)
            *
         CASE CMD = "SEARCHST"
            *
            CALL SEARCH.ST.SELECT2(JSON, SECURITY.REC, ERROR)
            IF ERROR = 0 THEN ERROR = ''
            IF ERROR NE '' THEN
               ERROR = "NOTES.MASTER, SEARCH.ST.SELECT2 ":ERROR
               IF DEBUG THEN WRITE ERROR ON F.RF, "ERROR"
               RETURN
            END
            *
         CASE CMD = "GETST"
            * SEND SOME STUFF BACK ABOUT THE STUDENT
            *
            CALL WPARSEJSON(BODY, 'id', STKEY, ERROR)
            READ STREC FROM F.ST, STKEY ELSE ERROR = "CANNOT READ THIS STUDENT ":STKEY:"---":BODY; GOTO STOP.ROUTINE
            IF STREC<11> EQ'' THEN ERROR = "CANNOT ACCESS THIS STUDENT - THEY APPEAR TO HAVE BEEN EXITED FROM SCHOOL "; GOTO STOP.ROUTINE
            * NEED THE ID IN THE BODY
            CALL NWBUILDJSON.SUB(BODY, "stkey", STKEY, '', ERROR)
            CALL WSETBODY(BODY)
            *
            CALL SCHOOL.DEMOGRAPHICS(JSON, SECURITY.REC, EMP.REC, ERROR); * CALL TO GET DEOMGRAPICS FROM A ACL
            IF ERROR = 0 THEN ERROR = ''
            IF ERROR NE '' THEN GOTO STOP.ROUTINE
            *
         CASE CMD = "GETSTNOTES"
            * GET THE NOTES - THIS IS A LIST OF NOTES FOR A STUDENT
            *
            GOSUB GETSTNOTES
            IF ERROR = 0 THEN ERROR = ''
            IF ERROR NE '' THEN GOTO STOP.ROUTINE
            *
         CASE CMD = "GETNOTE"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            *
            CMD = "GET"
            GOSUB GETNOTE
            IF ERROR = 0 THEN ERROR = ''
            IF ERROR NE '' THEN GOTO STOP.ROUTINE
            *
         CASE CMD = "SAVENOTE"
            * AJAX CALL TO SAVE A STUDENTS NOTES
            *
            CMD = "SAVE"
            GOSUB GETNOTE
            IF ERROR = 0 THEN ERROR = ''
            IF ERROR NE '' THEN GOTO STOP.ROUTINE
            *
         CASE CMD = "TRANS"
            * CALL THE SUBROUTINE AND GET A TRANSCRIPT IN NOTES.TRANSCRIPT.SUB
            *
            CMD = "TRANS"
            GOSUB GETNOTE
            IF ERROR = 0 THEN ERROR = ''
            IF ERROR NE '' THEN GOTO STOP.ROUTINE
            *
         CASE CMD = "GETNOTESTYPE"
            *  CALL ON LOAD TO GET NOTE TYPES FOR MENU
            *
            CALL WPARSEJSON(BODY, 'id', STKEY, ERROR)
            *
            DOME = "SSELECT NOTES.TYPE BY-DSND DESC BY SUBTYPE"
            DOME := ' WITH STATUS = "A"'
            EXECUTE DOME CAPTURING OUTPUT
            IF DEBUG THEN WRITE DOME:FM:OUTPUT ON F.RF, "NOTES.TYPE"

            OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; GOTO STOP.ROUTINE

            S1 = "key":fm:"var":fm:"title":fm:"menu":fm:"icon":fm:"cnt"

            DONE = 0; NOTESTYPE = ''
            LOOP
               READNEXT KEY ELSE DONE = 1
            UNTIL DONE
               READ TYPE.REC FROM F.TYPE, KEY THEN
                  * WHAT IF WE ADD SECURITY HERE.  ONLY SHOW IN LIST THOSE i HAVE ACCESS TOO
                  LOCATE POSITION IN TYPE.REC<10> SETTING POS THEN

                     NOTESTYPE = INSERT(NOTESTYPE, 1, -1; KEY)
                     NOTESTYPE = INSERT(NOTESTYPE, 2, -1; TYPE.REC<6>)
                     NOTESTYPE = INSERT(NOTESTYPE, 3, -1; TYPE.REC<7>)
                     NOTESTYPE = INSERT(NOTESTYPE, 4, -1; TYPE.REC<8>)
                     NOTESTYPE = INSERT(NOTESTYPE, 5, -1; TYPE.REC<9>)
                  END
               END
            REPEAT
            FOR I = 1 TO DCOUNT(NOTESTYPE<1>, VM)
               NKEY = NOTESTYPE<1,I>
               DOME = 'COUNT ST.NOTES WITH STUID = "':STKEY:'" AND WITH TYPE = "':NKEY:'"'
               IF I = 1 THEN
                  * THIS IS A PRIVATE NOTE, ONLY SHOW MINE.
                  DOME := ' AND WITH SECID = "':SECURITY.KEY:'"'
               END
               EXECUTE DOME CAPTURING OUTPUT
               TMP =  FIELD(OUTPUT, ' ', 2)
               IF TMP = "no" THEN TMP = 0
               NOTESTYPE = INSERT(NOTESTYPE, 6, -1; TMP)
            NEXT I

            TMP = ''
            FOR X = 1 TO DCOUNT(NOTESTYPE, FM)
               FOR I = 1 TO DCOUNT(NOTESTYPE<1>, VM)
                  TMP<I,X> = NOTESTYPE<X,I>
               NEXT I
            NEXT X

            CALL NWBUILDJSON.SUB(JSON, S1, TMP, 'NOTES', ERROR)
            *
         CASE CMD = "GETINCIDENTCODES"
            *
            DOME = 'SELECT NOTES.INCIDENT.CODES BY KEY WITH STATUS = "A"'
            EXECUTE DOME CAPTURING OUTPUT
            IF DEBUG THEN WRITE DOME:FM:OUTPUT ON F.RF, 'DOME'
            IF SYSTEM(11) = 0 THEN
               CALL NWBUILDJSON.SUB(JSON, 'error', "nothing found to display", '', ERROR)
               RETURN
            END

            CALL JSON.OBJECT.SUB(JSON, 'NOTES.INCIDENT.CODES', '', ERROR)

            RETURN
            *
         CASE 1
            *
            STOP.MSG = "REALLY NEED SOME HELP HERE - NOTES.MASTER ++":CMD:"++"
            GOTO STOP.ROUTINE
            *
      END CASE

      RETURN

!* -----------
GETSTNOTES: ;*
!* -----------
      *
      * GET A LIST OF THE NOTES FOR THIS STUDENT AND FOR THIS GROUP
      *
      CALL WPARSEJSON(BODY, "stkey", STKEY, ERROR)
      READ ST.REC FROM F.ST, STKEY ELSE ERROR = "CANNOT READ THIS STUDENT TODAY"; GOTO STOP.ROUTINE

      CALL CHECK.ST.ACCESS.SUB(ACCESS, ST.REC, SECURITY.REC, ERROR)
      *
      IF ACCESS = 0 THEN
         ERROR = "Student is not in your school, sorry - ST.NOTES"
         GOTO STOP.ROUTINE
      END
      CALL WPARSEJSON(BODY, "groupnum", GROUP, ERROR)
      IF GROUP = '' THEN ERROR = "NEED A GROUP TO WORK WITH"; GOTO STOP.ROUTINE

      DOME = 'SELECT ST.NOTES BY-DSND DATE BY-DSND TIME WITH STUID = "':STKEY:'" AND  WITH TYPE = "':GROUP:'"'
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) = 0 THEN RETURN

      IF DEBUG THEN WRITE DOME:FM:OUTPUT ON F.RF, "DOME-GETNOTES"

      BEGIN CASE
         CASE GROUP = 1
            DOME = 'SELECT ST.NOTES WITH SECID = "':SECURITY.KEY:'"'
            EXECUTE DOME CAPTURING OUTPUT
         CASE GROUP = 5
            DOME = 'SSELECT ST.NOTES BY MGTIME.RAW BY MGDATE.RAW'
      END CASE

      IF DEBUG THEN WRITE DOME:FM:OUTPUT ON F.RF, 'DOME'

      IF SYSTEM(11) = 0 THEN
         CALL NWBUILDJSON.SUB(JSON, 'key', "", 'NOTES', ERROR)
         RETURN
      END

      CALL JSON.OBJECT.SUB(JSON, 'NOTES.STLIST', '', ERROR)

      IF DEBUG THEN WRITE JSON ON F.RF, 'MYJSON'

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      *
      * GET AN INDIVIDUAL NOTE FOR THIS STUDENT
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)
      IF STKEY = '' THEN STOP.MSG = "REALLY, NEED A STUDENT SO NOTE CAN BE CREATED"; GOTO STOP.ROUTINE
      READ ST.REC FROM F.ST, STKEY ELSE ERROR = "CANNOT READ THIS STUDENT TODAY"; GOTO STOP.ROUTINE

      CALL CHECK.ST.ACCESS.SUB(ACCESS, ST.REC, SECURITY.REC, ERROR)
      *
      IF ACCESS = 0 THEN
         ERROR = "Student is not in your school, sorry - ST.NOTES"
         GOTO STOP.ROUTINE
      END

      CALL WPARSEJSON(BODY, 'notekey', NOTEKEY, ERROR)
      *
      DISABLED = 'true'
      *
      IF NOTEKEY = 'new' THEN
!* CREATE A NEW NOTE?
         CALL WPARSEJSON(BODY, 'groupnum', GROUPNUM, ERROR)
         IF GROUPNUM NE '' THEN
            READVU NOTEKEY FROM F.NEXTNUM, 'STNOTES', 1 THEN
               NOTEKEY += 1
               WRITEV NOTEKEY ON F.NEXTNUM, 'STNOTES', 1
               TMP = STKEY
               TMP<2> = SECURITY.KEY
               TMP<3> = MY.SCHOOL
               TMP<4> = GROUPNUM
               TMP<5> = TODAY
               TMP<6> = TIME()
               WRITE TMP ON F.NOTES, NOTEKEY
            END
            * NOTIFICATION IF NEW NOTE CREATED.
            READ NOTE.TYPE.REC FROM F.TYPE, GROUPNUM ELSE STOP.MSG = "NEW NOTE AND BAD GROUPNUM "; GOTO STOP.ROUTINE
            IF NOTE.TYPE.REC<12> NE '' THEN
               NOTIFICATION.CNT = DCOUNT(NOTE.TYPE.REC<12>, VM)
               FOR I = 1 TO NOTIFICATION.CNT
                  DOME = 'TABLIST SECURITY ID-SUPP ':NOTE.TYPE.REC<12,I>:' PREFEREDNAME '
                  EXECUTE DOME CAPTURING X.TO
                  CONVERT TAB TO '' IN X.TO
                  X.TO := "@seviersd.org"
                  X.SUBJECT = 'NOTES - ':NOTE.TYPE.REC<8>:' - New Note ':STKEY
                  X.TEXT = NOTE.TYPE.REC<8>:" Note for ":STKEY:" Created by ":SECURITY.REC<2>:" ":SECURITY.REC<1>
                  RESPONSE = ''
                  WRITE X.TO ON F.RF, 'XTO'
                  CALL WEB.EMAIL.AUTO( RESPONSE, X.TO, X.SUBJECT, X.TEXT )
               NEXT I
            END

         END
         DISABLED = "false"
      END
      *
      READ NOTE FROM F.NOTES, NOTEKEY ELSE ERROR = "CANNOT READ THIS NOTE ":NOTEKEY; GOTO STOP.ROUTINE
      * NOW THAT I HAVE THE NOTE.  MUST GO TO APPROPRIATE GROUP.
      TYPE = NOTE<4>
      READ NOTE.TYPE.REC FROM F.TYPE, TYPE ELSE ERROR = "WHAT, CANNOT FIND THAT TYPE"; GOTO STOP.ROUTINE
      TYPE.NAME = NOTE.TYPE.REC<6>; * THE PROGRAM NAME
      TYPE.EDIT = NOTE.TYPE.REC<11>; * WHO CAN EDIT THE NOTE
!* SHOULD WE DELETE THE NOTE
      CALL WPARSEJSON(BODY, 'delete', DELETEME, ERROR)
      IF DELETEME = "delete" THEN
         IF DEBUG THEN WRITE BODY ON F.RF, 'DELETE-BODY'
         GOTO DELETENOTE
      END
      *
!* call the program subroutine
      PROGRAM.NAME = "NOTES.":TYPE.NAME:".SUB"
      *
      OPEN 'BP' TO F.BP ELSE ERROR = "BAD DAY"; GOTO STOP.ROUTINE
      READ TMP FROM F.BP, PROGRAM.NAME ELSE ERROR = "NO PROGRAM YET ":TYPE:"-":PROGRAM.NAME; GOTO STOP.ROUTINE
      *
      * NOTES.AUP.SUB
      * NOTES.PRIVATE.SUB
      * NOTES.MEDICALGIVEN.SUB
      * NOTES.FOODALS.SUB
      * NOTES.TRANSCRIPT.SUB 11/29/22
      * NOTES.CALLNURSE.SUB  12/1/22
      * NOTES.HEALTHPLAN.SUB 12/7/22
      *
      CALL @PROGRAM.NAME(JSON, NOTEKEY, CMD, ERROR)
      IF ERROR = 0 THEN ERROR = ''
      IF ERROR NE '' THEN
         ERROR = PROGRAM.NAME:" - ":ERROR
         GOTO STOP.ROUTINE
      END
      *
      * ADD THE READONLY FLAG
      READONLY = "true"
      * DISABLED SET ABOVE NEW RECORD CHECK.  DISABLED = FALSE IF NEW
      IF NOTE<2> EQ SECURITY.KEY THEN
         READONLY = "false"
      END
      * SEE IF SECURITY.KEY CAN EDIT ALL THE NOTES, BY NOTE.TYPE
      IF DEBUG THEN WRITE TYPE.EDIT:FM:SECURITY.KEY:FM:TYPE ON F.RF, "CCC"
      LOCATE SECURITY.KEY IN TYPE.EDIT<1> SETTING POS THEN
         READONLY = 'false'
         DISABLED = 'false'
      END

      CALL NWBUILDJSON.SUB(JSON, "readonlyflag", READONLY, '', ERROR)
      CALL NWBUILDJSON.SUB(JSON, "disabledflag", DISABLED, '', ERROR)

      IF DEBUG THEN WRITE JSON ON F.RF, 'RETURNJSON'

      RETURN
      *
DELETENOTE: ;*
      * AJAX CALL TO DELETE A STUDENTS NOTE
      *
      IF DEBUG THEN WRITE "DELETE" ON F.RF, 'DELETE'

      READU NOTE FROM F.NOTES, NOTEKEY ELSE ERROR = "CANNOT READ THIS NOTE ":NOTEKEY; GOTO STOP.ROUTINE
      * NOW THAT I HAVE THE NOTE.  MUST GO TO APPROPRIATE GROUP.
      LOCATE SECURITY.KEY IN TYPE.EDIT<1> SETTING POS THEN
         SECURITY.KEY = NOTE<2>
      END

      IF NOTE<2> NE SECURITY.KEY THEN
         ERROR = "THIS IS NOT YOUR NOTE TO DELETE"
         RETURN
      END ELSE
         NOTE.REC    = NOTE<1>
         NOTE.REC<4> = NOTE<4>

         WHO = INITIALS:"*":REMOTEHOST
         * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
         NOTEKEY<2> = 11; * NUMBER OF ATTRIBUTES TO CHECK - THIS IS ABOVE THE 11 ALREADY CHECKING
         NOTEKEY<3> = 50

         NOTE.REC.ORG = NOTE

         CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)
         EXECUTE "DELETE ST.NOTES ":NOTEKEY CAPTURING WARNING
         WRITE WARNING ON F.RF, 'WARNING'
         CALL NWBUILDJSON.SUB(JSON, "warning", WARNING, '', ERROR)
!* AND WE NEED TO REMOVE ANY UPLOADED FILES
         IF DEV NE 1 THEN
            DOME = "!ssh www  'rm -rf /var/www/www/components/com_seviersd/views/notes/upload/":STKEY:"/":NOTEKEY:"'"
            EXECUTE DOME CAPTURING D
            DOME = "!ssh www 'rmdir /var/www/www/components/com_seviersd/views/notes/upload/":STKEY:"'"
            EXECUTE DOME CAPTURING D
         END

      END

      RETURN

!* -----------
STOP.ROUTINE: ; *
!* -----------
      *JSON = ''
      STOP.MSG := "(NOTES.MASTER-":ERROR:")"
      WRITE STOP.MSG ON F.RF, 'STOP.MSG'
      CALL NWBUILDJSON.SUB(JSON, "error", STOP.MSG, '', ERROR)
      ERROR = 0

      RETURN

      SUBROUTINE NOTES.MEDICALGIVEN.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * MEDICAL GIVEN NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN
      OPEN "DICT ST.NOTES" TO F.DICT.NOTES ELSE ERROR = "CANNOT OPEN DICT NOTES"; RETURN
      OPEN "JSONCONTROL"  TO F.JCONTROL ELSE ERROR = "CANNOT OPEN JSONCONTROL"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.MEDICALGIVEN.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      *
      *DOME = "SELECT ST.NOTES ":NOTEKEY
      *EXECUTE DOME CAPTURING OUTPUT
      *CALL JSON.OBJECT.SUB(JSON, 'NOTES-MEDGIVEN-MYFORM', '', ERROR)

      * attributes 40-59 will contain multivalue rows of the medication given
      *
      READ NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "CANNOT READ THIS NOTE ":NOTEKEY
      READV MYVARS FROM F.JCONTROL, "NOTES-MEDGIVEN-MYFORM", 3
      *
      *MYVARS = "mgHowmgInsulinmgQtymgDosageYpemgMedmgDosageStudentmgDateTimemgShotmgSugarmgLevelmgCarbsmgCorrectionmgTotalUnitsmgCarbsCorrectionmgLcarbsmgUnitsmgLunitsmgTotalmgDosageused"
      MYLOC = ''
      IF DEBUG THEN WRITE MYVARS ON F.RF, "MYVARS"
      FOR I = 1 TO DCOUNT(MYVARS, VM)
         THIS.VAR = MYVARS<1,I>
         READV  TMP FROM F.DICT.NOTES, THIS.VAR, 2
         MYLOC<1,I> = TMP
      NEXT I
      JSONDEF = "myformList"
      JSONDEF<2> = MYVARS
      JSONDEF<3> = MYLOC
      JSONDEF<4> = "Y"
      * FIX THE DATE TIME
      FOR X = 1 TO DCOUNT(NOTE.REC<46>, VM)

         VUEDATE = ''
         THIS.DATE = NOTE.REC<46,X>
         THIS.TIME = NOTE.REC<47,X>

         CALL CONVERT.DATE.SUB( VUEDATE, THIS.DATE, THIS.TIME, ERROR)
         IF DEBUG THEN WRITE VUEDATE ON F.RF, 'VDATE'
         NOTE.REC<46,X> = VUEDATE

      NEXT X

      CALL JSON.BUILDMY.SUB(JSON, JSONDEF, NOTE.REC, ERROR)
      IF ERROR = 0 THEN ERROR = ''
      IF ERROR NE '' THEN WRITE ERROR ON F.RF, 'ERROR'

      IF JSON = '{"myformList":[}' THEN
         JSON = ''
      END
      IF DEBUG THEN WRITE JSON ON F.RF, 'AFTERMYFORMLIST'

      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-MEDGIVEN', '', ERROR)

      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-MEDGIVEN', 'ST.NOTES', NOTE.REC, ERROR)
      *CALL SAVE.JSONCONTROL('NOTES-MEDGIVEN-MYFORM', 'ST.NOTES', NOTE.REC, ERROR)
      *
      READV MYVARS FROM F.JCONTROL, "NOTES-MEDGIVEN-MYFORM", 3
      *MYVARS = "mgDateTimemgShotmgSugarmgLevelmgCarbsmgCorrectionmgTotalUnitsmgCarbsCorrectionmgLcarbsmgUnitsmgLunitsmgTotalmgDosageused"
      FOR I = 1 TO DCOUNT(MYVARS, VM)
         THIS.VAR = MYVARS<1,I>
         READV  ATTR FROM F.DICT.NOTES, THIS.VAR, 2
         
         CALL WPARSEJSON(BODY, THIS.VAR, THIS.VAL, ERROR)

         IF THIS.VAR = "mgDateTime" THEN
            THIS.DATE = ''; THIS.TIME = ''

            CALL CONVERT.DATE.SUB( THIS.VAL, THIS.DATE, THIS.TIME, ERROR)

            NOTE.REC = INSERT(NOTE.REC, 46, 1; THIS.DATE)
            NOTE.REC = INSERT(NOTE.REC, 47, 1; THIS.TIME)
         END ELSE
            IF THIS.VAL = '' THEN THIS.VAL = " "
            NOTE.REC = INSERT(NOTE.REC, ATTR, 1; THIS.VAL)
         END
      NEXT I
      WRITE NOTE.REC ON F.NOTES, NOTEKEY

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      NOTEKEY<2> = 40; * NUMBER OF ATTRIBUTES TO CHECK
      NOTEKEY<3> = 59; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      CALL NWBUILDJSON.SUB(JSON, 'message', "Record Saved", '', ERROR)

      RETURN

      SUBROUTINE NOTES.PRIVATE.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * PRIVATE NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.PRIVATE.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-PRIVATE', '', ERROR)
      CALL NWBUILDJSON.SUB(JSON, "empty", '', 'myform', ERROR)

      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-PRIVATE', 'ST.NOTES', NOTE.REC, ERROR)

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      *NOTEKEY<2> = 12; * NUMBER OF ATTRIBUTES TO CHECK
      *NOTEKEY<3> = 12; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      *
      RETURN

      SUBROUTINE NOTES.TRANSCRIPT.SUB(JSON, NOTEKEY, CMD, ERROR)
      *
      *
      * TRANSCRIPT NOTE TYPE GET AND SAVE SUBROUTINE
      *
      DEBUG = 0
      *
      ERROR = 0; STOP.MSG = ''
      TODAY = DATE(); NOW = TIME()
      JSON = ''; TMP = ''

      $INCLUDE I_STDFILES_JOOMLA

      OPEN "ST.NOTES" TO F.NOTES ELSE ERROR = "CANNOT OPEN NOTES"; RETURN
      OPEN "NOTES.TYPE" TO F.TYPE ELSE ERROR = "CANNOT OPEN NOTES.TYPE"; RETURN

      CALL WGETBODY(BODY)
      *
      IF DEBUG THEN
         WRITE BODY ON F.RF, "NOTES.TRANSCRIPT.BODY*":NOW
      END
      *
      CALL WPARSEJSON(BODY, "sid", EMPNUM, ERROR)
      CALL WPARSEJSON(BODY, 'initials', INITIALS, ERROR)
      CALL WPARSEJSON(BODY, 'remote_host', REMOTEHOST, ERROR)
      *
      CALL WPARSEJSON(BODY, 'stkey', STKEY, ERROR)

      BEGIN CASE
         CASE CMD = "GET"
            * GET THE NOTE - THIS IS A SINGLE NOTE FOR A STUDENT
            GOSUB GETNOTE
            *
         CASE CMD = "SAVE"
            * AJAX CALL TO SAVE A STUDENT NOTE
            GOSUB SAVENOTE
            *
         CASE CMD = "TRANS"
            *
            GOSUB TRANSCRIPT
            *
         CASE 1
            ERROR = "DIDN'T KNOW WHAT TO DO SO..... SORRY"
      END CASE

      RETURN

!* -----------
GETNOTE: ;*
!* -----------
      DOME = "SELECT ST.NOTES ":NOTEKEY
      EXECUTE DOME CAPTURING OUTPUT
      IF SYSTEM(11) NE 1 THEN ERROR = "BAD SELECT ST.NOTES ":NOTEKEY; RETURN

      CALL JSON.OBJECT.SUB(JSON, 'NOTES-PRIVATE', '', ERROR)
      CALL NWBUILDJSON.SUB(JSON, "empty", '', 'myform', ERROR)

      RETURN

!* ----------
SAVENOTE: ;*
!* ----------
      *
      READU NOTE.REC FROM F.NOTES, NOTEKEY ELSE ERROR = "WHAT BAD NOTE"; RETURN
      NOTE.REC.ORG = NOTE.REC

      CALL SAVE.JSONCONTROL('NOTES-PRIVATE', 'ST.NOTES', NOTE.REC, ERROR)

      WHO = INITIALS:"*":REMOTEHOST
      * PROGRAM WILL UPDATE DATE/TIME/WHO AND CREATE A AUDITLOG IF CHANGED
      *NOTEKEY<2> = 12; * NUMBER OF ATTRIBUTES TO CHECK
      *NOTEKEY<3> = 12; * NUMBER TO CHECK
      CALL NOTES.AUDIT.SUB(NOTE.REC.ORG, NOTE.REC, WHO, NOTEKEY, ERROR)

      *
      RETURN

!* -----------
TRANSCRIPT: ;*
!* -----------
      *
      OPEN "ST.SECURITY" TO F.ST.SECURITY ELSE ERROR = "CANNOT OPEN SECURITY FILE"; RETURN
      READV SCHOOL FROM F.ST, STKEY, 11

      STUFF = '2022'
      STUFF<2> = SCHOOL
      STUFF<3> = STKEY
      STUFF<4> = 'PDF':VM:STKEY:VM:'c:\users\d3stuff\transcript':VM:'transcript-':STKEY
      STUFF<5> = 1
      STUFF<6> = STKEY

      CALL WEB.TRX.RPTS.EP(JSON, SECURITY.REC, STUFF, ERROR)

      READ SEC.REC FROM F.ST.SECURITY, STKEY ELSE SEC.REC = ''
      IF SEC.REC<30> = '' THEN
         CALL PASSWORD.RANDOM.SUB(PASSWORD)
         SEC.REC<30> = PASSWORD
         WRITE SEC.REC ON F.ST.SECURITY, STKEY
      END
      SLEEP 5
      *CRT "MY SALT IS ":SEC.REC<30>
      EXECUTE "cd /home/pick/php"
      * encrypt file
      EXECUTE '!php transcript.php transcript-':STKEY:'.pdf ':SEC.REC<30>:' ':STKEY
      SLEEP 5
      mydir = "/var/www/www/components/com_seviersd/views/notes/upload/":STKEY
      *crt mydir
      * create directory if doesn't exeist fro student
      EXECUTE "!ssh www 'mkdir -p ":mydir:"'"
      mydir = "/var/www/www/components/com_seviersd/views/notes/upload/":STKEY:'/':NOTEKEY
      *crt mydir
      * create note # directory if doesnt exist.
      EXECUTE "!ssh www 'mkdir -p ":mydir:"'"
      * scp copy file to web server
      EXECUTE "!scp /home/pick/d3stuff/transcript/transcript-":STKEY:".pdf.enc www:/var/www/www/components/com_seviersd/views/notes/upload/":STKEY:'/':NOTEKEY:'/transcript-':STKEY:"-":OCONV(TODAY, 'D2-'):".pdf"
      * remove original file
     * EXECUTE "!rm /home/pick/d3stuff/transcript/transcript-":STKEY:".pdf.enc"
     * EXECUTE "!rm /home/pick/d3stuff/transcript/transcript-":STKEY:".pdf"

      IF DEBUG THEN WRITE JSON:FM:SEC.REC<30> ON F.RF, 'SALT'
      * LETS LOG THE TRANSCRIPT CALL TO WEB.LOG.PROGRAM
      CALL SSD.WEBLOG.SUB('TRANSCRIPT')

      RETURN

      SUBROUTINE WPARSEJSON(JSON_STRING,JSON_REQUEST,JSON_RESULT,JSON_ERRORS)
      * Created 8/13/2016
      *
      * this is to be a simple json parser, it will not be high performance!!
      *
      * COMMAND WILL BE QM STYLE
      *
      * object or #/object or #/object or #
      *
      * lets do this VERY ugly, we know what we are looking for should be in the format
      * "key":  or "key" :
      *
      JSON_ERRORS=''
      JSON_RESULT=''
      MAX_LENGTH=LEN(JSON_STRING)
      FIRST_KEY=FIELD(JSON_REQUEST,'/',1); * WE CAN ONLY DO SINGLE DEPTH ON THIS VERSION
      IF FIRST_KEY[1,1]='[' THEN
         GOSUB getobject
         RETURN
      END
      SEARCH_STRING1='"':FIRST_KEY:'":'
      SEARCH_STRING2='"':FIRST_KEY:'" :'
      POS=INDEX(JSON_STRING,SEARCH_STRING1,1)
      IF NOT(POS) THEN
         POS=INDEX(JSON_STRING,SEARCH_STRING2,1)
      END
      IF NOT(POS) THEN
         JSON_ERRORS=-1
         JSON_ERRORS<2>='COULD NOT FIND KEY ':FIRST_KEY
         * PRINT 'ERROR'
         RETURN
      END
      TEMP_DATA=JSON_STRING[POS,MAX_LENGTH]
      *PRINT 'TEMP_DATA=':TEMP_DATA
      * NOW LETS CHOP TO OUR FIRST :
      POS2=INDEX(TEMP_DATA,':',1)
      TEMP_DATA=TEMP_DATA[POS2+1,MAX_LENGTH]
      * NOT SURE IF WE HAVE TO DEAL WITH DATA BEING NOT IN QUOTES, TO MAKE SURE WE ARE GOING TO INSPECT THE NEXT TWO POSITIONS
      * AND MAKE SURE
      *PRINT 'TEMP_DATA=':TEMP_DATA
      TEMP_DATA=TRIM(TEMP_DATA,' ','L')
      BEGIN CASE
            *CASE TEMP_DATA[1,1] = '"' OR TEMP_DATA[2,1] = '"'
         CASE TEMP_DATA[1,1] = '"'
            * QUOTES
            TEMP_DATA=FIELD(TEMP_DATA,'"',2,9999)
            *PRINT 'TEMP_DATA=':TEMP_DATA
            * WE CANNOT RELY ON IT JUST BEING THE NEXT QUOTE DUE TO ESCAPING !!@#$#$
            LEN_STRING=LEN(TEMP_DATA)
            FOUND_QUOTE=0
            LAST_C=''
            FOR X=1 TO LEN_STRING UNTIL FOUND_QUOTE
               C=TEMP_DATA[X,1]
               NEXTC=TEMP_DATA[X+1,1]
               *PRINT 'C=':C:' NEXT_C=':NEXT_C
               IF C='\' AND NEXTC='"' THEN
                  JSON_RESULT:='"'
                  X+=1
                  CONTINUE
               END
               IF C='"' THEN
                  FOUND_QUOTE=1
                  EXIT
               END ELSE
                  JSON_RESULT:=C
                  *PRINT 'JSON_RESULT=':JSON_RESULT
               END
               IF X > LEN_STRING THEN FOUND_QUOTE=1
            NEXT X
         CASE TEMP_DATA[1,1]='[' OR TEMP_DATA[2,1]='['; * WE ARE PULLING AN ARRAY.  THIS IS VERY MESSY.  IT CAN ONLY HANDLE A SINGLE ARRAY. ANY MORE NESTING AND WE ARE BROKE
            * WE NEED TO LOOP UNTIL WE SEE THE NEXT ] THAT IS NOT IS A INSIDE QUOTES
            LEN$STRING=LEN(TEMP_DATA)
            FOUND$BRACKET=0
            LAST$C=''
            INSIDE$QUOTES=0
            FOR X=1 TO LEN$STRING UNTIL FOUND$BRACKET
               C=TEMP_DATA[X,1]
               BEGIN CASE
                  CASE C=']' AND NOT(INSIDE$QUOTES); FOUND$BRACKET=1
                  CASE C='"' AND INSIDE$QUOTES; INSIDE$QUOTES=0
                  CASE C="'" AND INSIDE$QUOTES; INSIDE$QUOTES=0
                  CASE C='"'; INSIDE$QUOTES=1
                  CASE C="'"; INSIDE$QUOTES=1
               END CASE
               JSON_RESULT:=C
            NEXT X
         CASE TEMP_DATA[1,1]='{' OR TEMP_DATA[2,1]='['; * WE ARE PULLING AN ARRAY.  THIS IS VERY MESSY.  IT CAN ONLY HANDLE A SINGLE ARRAY. ANY MORE NESTING AND WE ARE BROKE
            * WE NEED TO LOOP UNTIL WE SEE THE NEXT ] THAT IS NOT IS A INSIDE QUOTES
            LEN$STRING=LEN(TEMP_DATA)
            FOUND$BRACKET=0
            LAST$C=''
            INSIDE$QUOTES=0
            FOR X=1 TO LEN$STRING UNTIL FOUND$BRACKET
               C=TEMP_DATA[X,1]
               BEGIN CASE
                  CASE C='}' AND NOT(INSIDE$QUOTES); FOUND$BRACKET=1
                  CASE C='"' AND INSIDE$QUOTES; INSIDE$QUOTES=0
                  CASE C="'" AND INSIDE$QUOTES; INSIDE$QUOTES=0
                  CASE C='"'; INSIDE$QUOTES=1
                  CASE C="'"; INSIDE$QUOTES=1
               END CASE
               JSON_RESULT:=C
            NEXT X
         CASE 1

            * IT SHOULD BE A NUMBER ONLY
            IF TEMP_DATA[1,1]=' ' THEN TEMP_DATA=TEMP_DATA[2,MAX_LENGTH]
            * NEXT CHARACTER WILL EITHER BE A },OR SPACXE
            NEXT1=INDEX(TEMP_DATA,'}',1)
            NEXT2=INDEX(TEMP_DATA,'}',1)
            NEXT3=INDEX(TEMP_DATA,',',1)
            N=NEXT1
            IF NEXT2 < N THEN N=NEXT2
            IF NEXT3 < N THEN N=NEXT3
            JSON_RESULT=TEMP_DATA[1,N-1]
      END CASE
      *CANNOT DO THIS IT BREAKS CARRIAGE RETURNS THAT MUST BE ESCAPED
      *JSON_RESULT = CONVERT(JSON_RESULT, "\/", "/")
      JSON_RESULT = CONVERT(JSON_RESULT, "//", "/")
      RETURN
      *
getobject: *
      OBJECTNUMBER=FIELD(FIRST_KEY,']',1)
      OBJECTNUMBER=FIELD(OBJECTNUMBER,'[',2)
      INSIDE$QUOTES=0
      OBJECTCOUNT=0
      CHARCNTR=0
      NESTCOUNT=0
      JSON_RESULT=''
      DOINGCOUNT=0
      LEN_JSON_STRING=LEN(JSON_STRING)
      IF OBJECTNUMBER='#' THEN
         OBJECTNUMBER=99999999
         DOINGCOUNT=1
      END
      LOOP
         CHARCNTR+=1
         IF CHARCNTR > LEN_JSON_STRING THEN EXIT
         C=JSON_STRING[CHARCNTR,1]
         BEGIN CASE
            CASE NOT(INSIDE$QUOTES) AND C='"'
               JSON_RESULT:=C
               INSIDE$QUOTES=1
            CASE INSIDE$QUOTES AND C='"'
               JSON_RESULT:=C
               INSIDE$QUOTES=0
            CASE INSIDE$QUOTES
               JSON_RESULT:=C
            CASE C='{' AND NOT(NESTCOUNT)
               * WE HAVE THE START OF OUR OBJECT
               JSON_RESULT=C
               NESTCOUNT=1
               OBJECTCOUNT+=1
            CASE C='{' AND NOT(INSIDE$QUOTES)
               * GOING A NEXT DEEPER
               JSON_RESULT:=C
               NESTCOUNT+=1
            CASE C='}'
               JSON_RESULT:=C
               NESTCOUNT=NESTCOUNT-1
               IF NESTCOUNT = 0 THEN
                  IF OBJECTNUMBER=OBJECTCOUNT-1 THEN
                     EXIT; * WE HAVE OUR OBJECT
                  END ELSE
                     NESTCOUNT=0
                     JSON_RESULT=''; * RESET OUR OBJECT
                  END
               END
            CASE NESTCOUNT=0; * DO NOTHING
            CASE 1
               JSON_RESULT:=C
         END CASE
         IF 0 THEN
            PRINT C,'NESTCOUNT=':NESTCOUNT:' OBJECTCOUNT=':OBJECTCOUNT:' INQUOTE=':INSIDE$QUOTES:' CHARCNTR=':CHARCNTR
         END
         IF DOINGCOUNT THEN JSON_RESULT=OBJECTCOUNT
      REPEAT
      IF 0 THEN
         PRINT JSON_RESULT
         PRINT
         PRINT JSON_STRING[1,CHARCNTR+50]
         INPUT WAIT
      END
      RETURN
      SUBROUTINE JSON.BUILDMY.SUB(JSON, JSONDEF, MYSTUFF, ERROR)
      *
      *  BUILD A JSON FROM EITHER A ITEM IN A FILE OR A VARIABLE BASED BY MYSTUFF
      *  FIRST USED IN LOCKDOWN.RPT.
      *  1/29/19
      *  9/19 - ADDED THE LOGIC AT BOTTOM TO POSSIBLY NOT CLOSE A ARRAY.  MIMIC THE START OF JSON LOGIC
      *
      * CDC 10/22  ADDED A CASE STATEMENT TO DEAL WITH BOOLIAN VARIABLES.
      *
      DEBUG = 0
      IF DEBUG THEN OPEN "RESULT.FILE" TO F.RF
      *
      *  LETS SAY THIS IS ALWAYS FRESH JSON
      *      JSON = ''
      ERROR = ''
      INCLUDE I_STDFILES_JOOMLA
      *
      IF JSONDEF = '' THEN ERROR = "NO DEF"; RETURN
      IF MYSTUFF = '' THEN ERROR = "NO STUFF"; RETURN
      *
      * JSONDEF<1> = ARRAY NAME FOR JSON
      * JSONDEF<2> = JSON ATTRIBUTE NAMES ]
      * JSONDEF<3> = ATTRIBUTE LOCATION FOR THE VAULES IN MYSTUFF
      * JSONDEF<4> = ALLWAYS AN ARRAY EVEN IF SINGLE VALUE Y/N
      * JSONDEF<10> = SUB ARRAY NAME ]
      * JSONDEF<11> = JSON SUB ARRAY NAMES /
      * JSONDEV<12> = SUB ARRAY ATTRIBUTE LOCATIONS.  SUB ARRAYS WILL BE IN SAME LOCATION BUT WITH SM /
      *
      JNAMES = JSONDEF<2>
      JVALUES = ''
      FOR I = 1 TO DCOUNT(JNAMES, VM)
         MYLOC = JSONDEF<3,I>
         JVALUES<I> = MYSTUFF<MYLOC>
      NEXT I
      *     * JVALUES SHOULD HAVE ] VALUES FOR EACH JNAMES
      *
      *     * START THE JSON OFF
      JVALUE.CNT = DCOUNT(JVALUES<1>, VM)
      IF JVALUE.CNT > 1 THEN
         JSON = '{"':JSONDEF<1,1>:'":['
      END ELSE
         JSON = '{"':JSONDEF<1,1>:'":['
      END
      *
      IF JSONDEF<4> = "Y" THEN
         JSON = '{"':JSONDEF<1,1>:'":['
      END
      *
      FOR I = 1 TO JVALUE.CNT
         FOR J = 1 TO DCOUNT(JNAMES, VM)
            IF J = 1 THEN JSON := "{ "
            MYNAME  = JNAMES<1,J>
            MYVALUE = JVALUES<J,I>
            CALL WENCODEJSON('',  MYNAME, OUT_NAME)
            CALL WENCODEJSON('',  MYVALUE, OUT_VALUE)
            JSON := ' "':OUT_NAME:'":"':OUT_VALUE:'"'
            IF J < DCOUNT(JNAMES, VM) THEN JSON := ','
         NEXT J
         *
         *        * DO WE HAVE ANY ARRAYS TO ADD TO THIS JSON ITEM
         IF DCOUNT(JSONDEF<10>, VM) > 0 THEN
            *        * WE HAVE A SUB ARRAY TO ADD TO THIS RECORD.
            FOR X = 1 TO DCOUNT(JSONDEF<10>, VM)
               MYARRAY.NAME = JSONDEF<10,X>
               ARRAY.JNAMES = JSONDEF<11,X>
               ARRAY.VALUES = JSONDEF<12,X>
               CONVERT SM TO FM IN ARRAY.JNAMES
               CONVERT SM TO FM IN ARRAY.VALUES
               *
               IF X = 1 THEN JSON := ","
               JSON := '"':MYARRAY.NAME:'" : ['
               *
               ARRAY.JNAMES.CNT = DCOUNT(ARRAY.JNAMES, FM)
               ARRAY.JVALUE = ''
               FOR II = 1 TO ARRAY.JNAMES.CNT
                  ARRAY.LOC = ARRAY.VALUES<II>
                  ARRAY.JVALUE<II> = MYSTUFF<ARRAY.LOC,I>
               NEXT II
               *
               ARRAY.JVALUE.CNT = DCOUNT(ARRAY.JVALUE<1,1>, SM)

               FOR II = 1 TO ARRAY.JVALUE.CNT
                  FOR JJ = 1 TO ARRAY.JNAMES.CNT
                     IF JJ = 1 THEN JSON := '{ ' ; * START THE ARRAY ITEM
                     MYNAME = ARRAY.JNAMES<JJ>
                     MYVALUE = ARRAY.JVALUE<JJ,1,II>
                     *
                     CALL WENCODEJSON('',  MYNAME, OUT_NAME)
                     CALL WENCODEJSON('',  MYVALUE, OUT_VALUE)
                     *
                     *BEGIN CASE
                        *CASE OUT_VALUE = "true"
                           *JSON := ' "':OUT_NAME:'":':OUT_VALUE:','
                        *CASE OUT_VALUE = "false"
                           *JSON := ' "':OUT_NAME:'":':OUT_VALUE:','
                        *CASE 1
                           JSON := ' "':OUT_NAME:'":"':OUT_VALUE:'"'
                     *END CASE


                     IF JJ < ARRAY.JNAMES.CNT THEN JSON := ',' ; * , BETWEEN VALUES
                  NEXT JJ
                  JSON := "}" ; * CLOSE THE ARRAY ITEM
                  IF II NE ARRAY.JVALUE.CNT THEN JSON := ","; * ADD , BETWEEN ITEMS
               NEXT II
            NEXT X
            *           * CLOSE THE ARRAY
            JSON := "]"
         END
         *        * ADD A , BETWEEN RECORDS
         IF I < JVALUE.CNT THEN
            JSON := '},'
         END ELSE
            JSON := '}'
         END
      NEXT I
      *
      *     * CLOSE THE JSON
      IF JVALUE.CNT > 0 THEN
         JSON := ']}'
      END ELSE
         JSON := '}'
      END



      ***      JSON := ']}'
      *
      *      IF DEBUG THEN CRT JSON
      IF DEBUG THEN WRITE JSON ON F.RF, "JSON"
      *
      RETURN

